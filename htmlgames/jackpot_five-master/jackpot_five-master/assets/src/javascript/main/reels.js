/*
	reels.js

	what these do:
		reads reel strips from rom
		setting up reels on the screen
		returns the reel index to stop according to a random number generated by RNG

	what these do not:
		anything about logic
*/

/*
	Sound file data model
*/
Gframe.backbone.models.strip = Backbone.Model.extend({
	defaults: function() {
		return {
			// id is a sequencial number of strip on reel, e.g. 0 ~ 2.
			'symbols': [], // Array containing symbol ids
			'chances' : [],// Array containing chances.
			'ranges': [],
			'totalChances': 128, // sum of chances.
			'totalStops': 22,
		};
	},
	initialize: function() {
		var _chances = this.get('chances');
		var _ranges = this.get('ranges');
		var _totalStops = _chances.length;
		var _sumOfChances = 0;
		for (var _i = 0; _i < _totalStops; _i++){
			_sumOfChances += _chances[_i];
			_ranges.push(_sumOfChances);
		}
		// Gframe.functions.utils.registerMediatorEvents ( this );
	},
});

// collection for the sound files. This collection will be used to generate a soundJS manifest for pre-loading.
Gframe.backbone.collections.strips = Backbone.Collection.extend({
	model: Gframe.backbone.models.strip
});

/*
	Important : Use of Backbone mediator event is encouraged when controlling audio elements through this View.
	Avoid direct access to this View
*/
Gframe.backbone.views.reels = Backbone.View.extend({
	'reel_stop_num': 22,
	'fallback': false,
	'soundSettings': {
		'reel_spin': 'reel_spin_1_a',
		'reel_spin_ri_ichi_low': 'reel_spin_2_a',
		'reel_spin_ri_ichi_high': 'reel_spin_3',
	},
	'currentReelSound': 'reel_spin_1_a',
	'teaser': [
		{'speed':300,'easing':'easeOutBounce', 'sound': 'step_stop_3'},
		{'speed':400,'easing':'easeOutBack', 'sound': 'step_stop_3'},
		{'speed':300,'easing':'easeInCirc', 'sound': 'step_stop_2'},
		{'speed':100,'easing':'easeInBack', 'sound': 'step_stop_1'},
	],
	'reel_holder_info': {
		'top': 238,
		'symbol_height': 87,
	},
	/*
		holds current wins of player
	*/
	'current_wins': [],
	/*
		Current total payout
	*/
	'current_totalPayout': 0,
	/*
		this is for keeping track of current total credit
		while memory / register value, credit, is used for segment display
	*/
	'current_credits': 0,
	/*
		current bet amount
	*/
	'current_bet_amount': 3,
	/*
		symbol_display_matrix is used to determine payout.
	*/
	'symbol_display_matrix': [
		['','',''],
		['','',''],
		['','',''],
	],
	/*
		for illuminating winning symbols
	*/
	'symbol_vfx_display_matrix': [
		['','',''],
		['','',''],
		['','',''],
	],
	/*
		The following array contains all the possible winning companinations
		Each payline is searched for a winning combination.
	*/
	'winning_combinations': {
		/*
			the triple cherries is searched first to eliminate duplicated detections
		*/
		'three_cherries':'cherry-cherry-cherry', // 3 Cherries
		/*
			two pairs
		*/
		'two_cherries':'((.*?)-cherry-cherry)|(cherry-cherry-(.*?))|(cherry-(.*?)-cherry)', // 2 Cherries
		/*
			finally single cherry
		*/
		'cherry':'((.*?)-(.*?)-cherry)|((.*?)-cherry-(.*?))|(cherry-(.*?)-(.*?))', // 1 Cherry
		/*
			three pairs
		*/
 		'seven':'seven-seven-seven', // 3 Sevens
		'bell':'bell-bell-bell', // 3 Bells
		'bar':'bar-bar-bar', // 3 Bars
		'prune':'prune-prune-prune', // 3 Prunes
		'orange':'orange-orange-orange', // 3 Oranges

	},
	'pay_tables': {
		'three_cherries':{'payout':10,'symbol':'cherry'},
		'two_cherries':{'payout':3,'symbol':'cherry'},
		'cherry':{'payout':1,'symbol':'cherry'},
		'seven':{'payout':1000,'symbol':'seven'},
		'bell':{'payout':500,'symbol':'bell'},
		'bar':{'payout':100,'symbol':'bar'},
		'prune':{'payout':50,'symbol':'prune'},
		'orange':{'payout':20,'symbol':'orange'}
	},
	'ri_ichi_combinations': {
		2: '(bar-(.*?)-bar)|((.*?)-bar-bar)|(bar-bar-(.*?))|(bar-bar-bar)|(prune-(.*?)-prune)|((.*?)-prune-prune)|(prune-prune-(.*?))|(prune-prune-prune)',
		3: '(seven-(.*?)-seven)|((.*?)-seven-seven)|(seven-seven-(.*?))|(seven-seven-seven)|(bell-(.*?)-bell)|((.*?)-bell-bell)|(bell-bell-(.*?))|(bell-bell-bell)'
	},
	'reel_info': {},
	'active_reels': {}, // array to keep ids of active reels of the moment.
	'triggerFunctions': [
		'reelStopper',
		'spinTheReel',
		'gameStartReady',
		'betControl'
	],
	'inPlay': false,
	'reelReady': 0,
	initialize: function(options) {
		// strips data is mandatory
		if(!options.collection) {
			throw new Error('Fatal: Gframe.backbone.views.reels requires Gframe.rom.reels.strips to be defined.');
			return false;
		}

		// set fallback mode enabled if csstransforms3d is not supported
		if( Boolean(Gframe.compatibility.csstransforms3d) === false ) {
			this.fallback = true;
		}
		// register events
		Gframe.functions.utils.registerMediatorEvents ( this );

		this.render();
		// update bootStatus
		Gframe.bootStatus.set('reels', true);
	},
	render: function () {
		var _reel_strip_model ;
		var _id;
		for (var _i = 0; _i < 3; _i++){
			_reel_strip_model_attributes = this.collection.at(_i).attributes;
			_id = _i + 1;
			this.setupStepper(_id,_reel_strip_model_attributes.totalStops);
			this.setReelStrips(_id,_reel_strip_model_attributes.symbols);
		}
	},
	/*
		functions for initializing reels

		note: the function creates stops with 3 additional ones.
				The additional stops are used to loop / rotate seamlessly
	*/
	setupStepper: function (_reel_id,_reel_stop_num) {
		var $_reel_holder = $('#reel_holder');
		var $_reel_elm = $('<div />',{
			'id': 'reel-'+_reel_id,
			'class': 'reel'
		});
		// fast auto-spin
		// transform: rotateX(#{360/$reelSteps*$i}deg) translateZ(160px);
		for (var _i = 0; _i < _reel_stop_num; _i++) {
			$_reel_elm.append(
				$('<div />',{
					'class':'symbol stop_'+_i,
					'html': '<p>'+_i+'</p>'
				})
			);
		}
		for (var _i = 0; _i < 3; _i++) {
			$_reel_elm.append(
				$('<div />',{
					'class':'symbol stop_'+_i,
					'html': '<p>'+(_i)+'</p>'
				})
			);
		}
		this.reel_info['reel-'+_reel_id] = {'totalStops': _reel_stop_num, 'stopNum': 0, 'virtualReelNumber': -1};
		$_reel_holder.append($_reel_elm);
	},
	/*
		functions for initializing the strip
	*/
	setReelStrips: function ( _reel_id, _reelStrip) {
		var _reel_stop_num = _reelStrip.length;
		var $_reel_holder = $('#reel_holder');
		var $_reel_elm = $('#reel-'+_reel_id).children();
		var $_step;
		var _symbol_index = 0;
		$('#reel-'+_reel_id + ' .symbol').addClass('shiny');
		for (var _i = 0 ; _i < _reel_stop_num ; _i++) {
			$_step = $($_reel_elm.eq(_i));
			$_step.addClass(_reelStrip[_i]);
		}
		for (var _i = 0 ; _i < _reel_stop_num ; _i++) {
			$_step = $($_reel_elm.eq(_i + _reel_stop_num));
			$_step.addClass(_reelStrip[_i]);
		}
	},
	/*
		BET control

		_context : null or omitted - update the display
		_context : true - count up to 3 then loop back to 1
		_context : false - MAX bet

		What it does
			update the display
			update the payline indicator
			play appropriate sound (if _context is set)

		Note: betControl() requires bet_count register.
	*/
	betControl: function ( _context ) {
		if(this.inPlay === true ) return false;
		var $_indicators = $('.payline .indicator');
		var $_first = $('.payline .indicator#first');
		var $_second = $('.payline .indicator#second');
		var $_third = $('.payline .indicator#third');
		Backbone.mediator.trigger( 'stopSound' , 'bet_' + this.current_bet_amount );
		if(_context === true) {
			// loop through 1 ~ 3
			if(this.current_bet_amount >= 3 ) {
				this.current_bet_amount = 1;
			} else {
				this.current_bet_amount++;
			}
		} else if (_context === false) {
			// max bet
			this.current_bet_amount = 3;
		}
		if(typeof _context !== 'undefined') {
			Backbone.mediator.trigger( 'playSound' , 'bet_' + this.current_bet_amount );
		}
		// update the segment
		Gframe.memory.mov({
			id: 'bet_count',
			value: this.current_bet_amount,
		});
		// update the indicator on the faceplate glass. 3 to 1.
		$_indicators.removeClass('bet');
		if(this.current_bet_amount >= 1) {
			$_first.addClass('bet');
		}
		if(this.current_bet_amount >= 2) {
			$_second.addClass('bet');
		}
		if(this.current_bet_amount >= 3) {
			$_third.addClass('bet');
		}
	},
	/*
		functions for controling reels
	*/
	/*
		Spin Reel
	*/
	spinTheReel: function () {
		if(this.inPlay === true ) return false;
		var _self = this;

		// stop all sound just in case
		Backbone.mediator.trigger( 'stopSound' );
		// remove any VFX (in case that credit count up has been canceled in the half way)
		Gframe.vfx.eraseVFX();
		// making sure that the credit segment is up to date (in case the payout count up animation was canceled.)
		this.updateCreditSegment();
		// just in case the segment animation is still going on.
		Gframe.clock.removeTimer('creditSegmentAnimation');
		// deduct credits
		if(!this.decreaseCredits()) {
			return false;
		}

		Backbone.mediator.trigger( 'gameStartReady' , false);

		/*
			Remove all the symbol shiny animation
		*/
		$('.symbol').removeClass('shiny');

		Gframe.memory.mov({
			id: 'winner_paid',
			value: 'GOODLUCK',
		});
		$('#reel-1').stop().animate({
				'margin-top': '+=160px'
			}, 400, 'easeInBack' , function () {
				_self.reelReady++;
				if(_self.reelReady >= 3) { // this number varies depending on the # of reels
					_self.startSpinningTheReels();
				}
			}
		);
		$('#reel-2').stop().delay(100).animate({
				'margin-top': '+=160px'
			}, 300, 'easeInBack' , function () {
				_self.reelReady++;
				if(_self.reelReady >= 3) { // this number varies depending on the # of reels
					_self.startSpinningTheReels();
				}
			}
		);
		$('#reel-3').stop().delay(200).animate({
				'margin-top': '+=160px'
			}, 200, 'easeInBack' , function () {
				_self.reelReady++;
				if(_self.reelReady >= 3) { // this number varies depending on the # of reels
					_self.startSpinningTheReels();
				}
			}
		);
	},
	startSpinningTheReels: function () {
		var _ri_ichi;
		var _reelSound;
		var _teaserDelay ;
		var _virtualReelNumber ;
		var _reelID;

		this.spinControl(1);
		this.spinControl(2);
		this.spinControl(3);

		// set the stop number
		for(var _i = 1; _i <= 3; _i++) {
			_virtualReelNumber = Gframe.functions.utils.RNG(128);
			/*
				for debugging
				use
					0: orange
					32: Prune
					120: Seven
				// _virtualReelNumber = 1;
			*/
			// _virtualReelNumber = 120;
			// this is where the next stop number of reels are determined.
			_reelID = 'reel-'+_i;
			this.reel_info[_reelID].virtualReelNumber = _virtualReelNumber;
			this.reel_info[_reelID].stopNum = this.findStopNumFromVirtualReelTable(_i, _virtualReelNumber);
		}
		// the result will already be generated but the player would not know about that yet.
		this.fillSymbolDisplayMatrix();
		this.evaluateWinningCombinations();
		//_reelSound is reel_spin by default
		_ri_ichi = this.detectRi_ichi();

		/*
			_ri_ichi is determinted by winning combinations and those considered as near miss.
			if this current result is winning or something close,  different BGM played accordingly.
		*/
		switch(_ri_ichi) {
			case '2':
				this.currentReelSound = this.soundSettings.reel_spin_ri_ichi_low;
				_teaserDelay = 1000;
				break;
			case '3':
				this.currentReelSound = this.soundSettings.reel_spin_ri_ichi_high;
				_teaserDelay = 2000;
				break;
			default:
				this.currentReelSound = this.soundSettings.reel_spin;
				_teaserDelay = 0;
				break;
		}

		Gframe.clock.addTimer({
			'id': 'reel_1',
			'loop': 0,
			'frequency': 1000 + _teaserDelay,
			'setInterval': false,
			timerFunction: function () {
				Backbone.mediator.trigger( 'reelStopper', 1 );
				Gframe.clock.removeTimer('reel_1_xtal');
				Gframe.clock.removeTimer('reel_1');
			}
		});
		Gframe.clock.addTimer({
			'id': 'reel_2',
			'loop': 0,
			'frequency': 1400 + _teaserDelay,
			'setInterval': false,
			timerFunction: function () {
				Backbone.mediator.trigger( 'reelStopper', 2 );
				Gframe.clock.removeTimer('reel_2_xtal');
				Gframe.clock.removeTimer('reel_2');
			}
		});
		Gframe.clock.addTimer({
			'id': 'reel_3',
			'loop': 0,
			'frequency': 1800 + _teaserDelay,
			'setInterval': false,
			timerFunction: function () {
				Backbone.mediator.trigger( 'reelStopper', 3 );
				Gframe.clock.removeTimer('reel_3_xtal');
				Gframe.clock.removeTimer('reel_3');
			}
		});

		/*
			This approach is taken because css anim is discovered not to always be the best way
			Firstly IE9 does not support CSS animations. 2ndly keyframed css animations loop caused flickering
			in Firefox.
			This routine needs more improvement in the future. or perhaps anything to do with screen drawing
			can be converted into a method using canvas.
		*/

		/* xtals for each reel */
		$_reel_1 = $('#reel-1');
		var _reel_1_margin_top = $_reel_1.css('margin-top').replace('px','');
		$_reel_2 = $('#reel-2');
		var _reel_2_margin_top = $_reel_2.css('margin-top').replace('px','');
		$_reel_3 = $('#reel-3');
		var _reel_3_margin_top = $_reel_3.css('margin-top').replace('px','');

		Gframe.clock.addTimer({
			'id': 'reel_1_xtal',
			'loop': -1,
			'frequency': 20,
			'setInterval': true,
			timerFunction: function () {
				if(_reel_1_margin_top < -1915) {
					_reel_1_margin_top = 0
				} else {
					_reel_1_margin_top -= 50;
				}
				$_reel_1.css('margin-top',_reel_1_margin_top);
			}
		});

		Gframe.clock.addTimer({
			'id': 'reel_2_xtal',
			'loop': -1,
			'frequency': 20,
			'setInterval': true,
			timerFunction: function () {
				if(_reel_2_margin_top < -1915) {
					_reel_2_margin_top = 0
				} else {
					_reel_2_margin_top -= 50;
				}
				$_reel_2.css('margin-top',_reel_2_margin_top);
			}
		});

		Gframe.clock.addTimer({
			'id': 'reel_3_xtal',
			'loop': -1,
			'frequency': 20,
			'setInterval': true,
			timerFunction: function () {
				if(_reel_3_margin_top < -1915) {
					_reel_3_margin_top = 0
				} else {
					_reel_3_margin_top -= 50;
				}
				$_reel_3.css('margin-top',_reel_3_margin_top);
			}
		});

		Gframe.clock.startTimer('reel_1');
		Gframe.clock.startTimer('reel_1_xtal');
		Gframe.clock.startTimer('reel_2');
		Gframe.clock.startTimer('reel_2_xtal');
		Gframe.clock.startTimer('reel_3');
		Gframe.clock.startTimer('reel_3_xtal');

		Backbone.mediator.trigger( 'playSound' , this.currentReelSound );
	},
	spinControl: function (_id) {
		var _currentReelID = 'reel-'+_id;
		var $_reel = $('#'+_currentReelID);
		var _spin = $_reel.hasClass('spin');
		if(!_spin) {
			this.active_reels[_currentReelID] = true;
		} else {
			delete this.active_reels[_currentReelID];
		}
	},
	/*
		simulates spins without movements
		for debugging purposes only
	*/
	simulateSpins: function ( _count ) {
		var _rng_monitor = [];
		var _stopNum_monitor = [];
		var _totalPayout = 0;
		var _combinationStatistics = {};
		var _virtualReelNumber;
		var _currentReelID;
		var _combination = '';
		var _payout = 0;
		for (var _i = 0; _i < _count; _i++){
			for (var _id = 1; _id < 4; _id++){
				_currentReelID = 'reel-'+_id;
				_virtualReelNumber = Gframe.functions.utils.RNG(128);
				_rng_monitor.push(_virtualReelNumber);
				this.reel_info[_currentReelID].virtualReelNumber = _virtualReelNumber;
				this.reel_info[_currentReelID].stopNum = this.findStopNumFromVirtualReelTable(_id, _virtualReelNumber);
				_stopNum_monitor.push(this.reel_info[_currentReelID].stopNum);
			}
			this.fillSymbolDisplayMatrix();
			this.evaluateWinningCombinations();
			for(var _scanWins = 0; _scanWins < this.current_wins.length ; _scanWins++ ) {
				_combination = this.current_wins[_scanWins].combination;
				_payout = this.current_wins[_scanWins].payout;
				if(_.has(_combinationStatistics, _combination)) {
					_combinationStatistics[_combination] += 1;
				} else {
					_combinationStatistics[_combination] = 1;
				}
				_totalPayout = _totalPayout + _payout;
			}
		}
		var _totalCreditsSpent = _count*3;
		var _payoutRate = Gframe.functions.utils.floatRound(_totalPayout / _totalCreditsSpent) * 100;

		console.log(
			"TOTAL SPINS: " + _count +"\n",
			"TOTAL CREDITS SPENT: $" + _totalCreditsSpent +"\n",
			"TOTAL PAYOUT: $" + _totalPayout +"\n",
			"PAYOUT RATE: " + _payoutRate +"%\n",
			JSON.stringify(_combinationStatistics),
			"\nRNG STATS\n",
			"RNG AVERAGE: " + Gframe.functions.utils.findAverage(_rng_monitor) + "\n",
			"RNG VARIANCE: " + Gframe.functions.utils.findVariance(_rng_monitor) + "\n",
			"RNG STANDARD DEVIATION: " + Gframe.functions.utils.findStandardDeviation(_rng_monitor) + "\n",
			"\nSTOP STATS\n",
			"STOP AVERAGE: " + Gframe.functions.utils.findAverage(_stopNum_monitor) + "\n",
			"STOP VARIANCE: " + Gframe.functions.utils.findVariance(_stopNum_monitor) + "\n",
			"STOP STANDARD DEVIATION: " + Gframe.functions.utils.findStandardDeviation(_stopNum_monitor) + "\n"
		);

		var rng_sorted = {};
		var _key = '';
		for (var i = 0; i < _stopNum_monitor.length; i++) {
			_key = _stopNum_monitor[i];
			if (rng_sorted.hasOwnProperty(_key)) {
				rng_sorted[_key]++;
			} else {
				rng_sorted[_key] = 1;
			}
		}
		console.log(JSON.stringify(rng_sorted));
	},
	/*
		determine stop number from virtual reel table.
		(reel) _id is required because each reel has different strips (they are all identical by factory default)
	*/
	findStopNumFromVirtualReelTable: function ( _id, _virtualReelNumber ) {
		var _reel_strip_model_attributes = this.collection.at(_id - 1).attributes;
		var _totalStops = _reel_strip_model_attributes.totalStops;
		var _ranges = _reel_strip_model_attributes.ranges;
		var _sumOfChances = 0;
		var _stopNum;
		for (var _i = 0; _i < _totalStops; _i++){
			if(_virtualReelNumber <= _ranges[_i]){
				/*
					_stopNum is one before because the payline is in the middle among the three columns
					_stopNum indicates where the top Rows are at.
				*/
				_stopNum =  _i - 1;
				if(_stopNum < 0) {
					_stopNum = _totalStops - 1;
				}
				return _stopNum;
				break;
			}
		}
	},
	/*
		the symbol display matrix variable is used for determining winning combinations for payout.
	*/
	fillSymbolDisplayMatrix: function () {
		var _SDM = this.symbol_display_matrix;
		var _strip_excerpts = [];
		var _stopNum_counter = 0;
		var _reel_strips = [];
		/*
			getting symbol sequence of each reel strip from model
			the symbols attribute holds an array, so the _reel_strips
			will have 3 arrays holding respective strips on those reels
		*/
		for(var _i = 0; _i < 3; _i++) {
			_reel_strips.push(this.collection.at(_i).attributes.symbols);
		}
		var _totalStops = _reel_strip_model_attributes.totalStops;

		for(var _column = 0; _column < 3; _column++) { // Column
			// _column or _row ranges from 0 to 2
			_stopNum_counter = this.reel_info['reel-' + (_column + 1)].stopNum;
			for(var _row = 0; _row < 3; _row++) { // Row
				_SDM[_row][_column] = _reel_strips[_column][_stopNum_counter];
				if(_stopNum_counter >= _totalStops - 1){
					_stopNum_counter = 0;
				} else {
					_stopNum_counter++;
				}
			}
		}
	},
	/*
		Evaluate winning combinations from the current matrix stored in symbol_display_matrix. e.g:
		[["blank","blank","prune"],
		["cherry","prune","blank"],
		["blank","blank","cherry"]]

		then the function populates current_wins and symbol_vfx_display_matrix.
	*/
	evaluateWinningCombinations: function (_debug) {
		var _SDM = this.symbol_display_matrix;
		this.symbol_vfx_display_matrix = [['','',''],['','',''],['','','']]; // reset matrix once
		var _winning_combinations = this.winning_combinations;
		var _pay_tables = this.pay_tables;
		var _joinedPayLine = '';
		this.current_wins = [];
		var _winningSymbol = '';
		var _current_bet_amount = this.current_bet_amount;
		var _paylines;
		if( _current_bet_amount === 3 ) {
			_paylines = [true, true, true];
		} else if ( _current_bet_amount === 2 ) {
			_paylines = [true, true, false];
		} else {
			_paylines = [false, true, false];
		}
		if(_debug==true) {
			console.log(JSON.stringify(_SDM));
		}
		for(var _row = 0; _row < 3; _row++) { // Row
			_joinedPayLine = _SDM[_row].join('-');
			if(_paylines[_row] === true) {
				if(_debug==true) {
					console.log(_joinedPayLine);
				}
				for(var _key in _winning_combinations) {
					if(_debug==true) console.log(_winning_combinations[_key]);
					// scan for combination patterns through each row
					if(_joinedPayLine.match(_winning_combinations[_key])) {
						if(_.has(_pay_tables,_key)) {
							this.current_wins.push({'combination':_key,'payout':_pay_tables[_key].payout});
							for(var _i = 0; _i < 3; _i++) {
								if(_SDM[_row][_i] == _pay_tables[_key].symbol) {
									this.symbol_vfx_display_matrix[_row][_i] = _pay_tables[_key].symbol;
								}
							}
						if(_debug==true) console.log(_key);
							// console.log(_SVDM);
						}
						// console.log("WON COMBINATION", "LINE: "+(_row+ 1)+' --- ' ,_key, new Date());
						break;
					}
				}
			}
		}
		if(this.current_wins.length > 0) {
			if(_debug==true) console.log(this.current_wins);
		}
	},
	/*
		detect Ri-ichi, (a Japanese word commonly used in Majhong or Gambling)
		meaning "Ready Hand" in english.
	*/
	detectRi_ichi: function (_debug) {
		var _ri_ichi_combinations = this.ri_ichi_combinations;
		var _SDM = this.symbol_display_matrix;
		var _joinedPayLine = '';
		var _ri_ichi = false;
		for(var _row = 0; _row < 3; _row++) { // Row
			_joinedPayLine = _SDM[_row].join('-');
			if(_debug==true) { console.log(_joinedPayLine);}
			for(var _key in _ri_ichi_combinations) {
				if(_debug==true) console.log(_ri_ichi_combinations[_key]);
				// scan for combination patterns through each row
				if(_joinedPayLine.match(_ri_ichi_combinations[_key])) {
					if(_debug==true) console.log(_key);
					_ri_ichi = _key;
					break;
				}
			}
		}
		return _ri_ichi;
	},
	/*
		this finds margin-top value at a certain stop.
	*/
	findMarginTopAt: function (_stop_num) {
		if(!_stop_num) _stop_num = 0;
		return -(this.reel_holder_info.symbol_height)*_stop_num;
	},
	/*
		Stops reel at stopNum
	*/
	reelStopper: function (_id) {
		var _self = this;
		var _currentReelID = 'reel-'+_id;
		var $_reel = $('#'+_currentReelID);
		$_reel.attr('class','reel');
		_stopNum = _self.reel_info[_currentReelID].stopNum;
		if(!_stopNum) _stopNum = 0;
		var _currentMarginTop = parseInt($_reel.css('margin-top').replace('px',''));
		var _reelStop_px = _self.findMarginTopAt(_stopNum);
		var _teaserNum;
		if (_reelStop_px  > _currentMarginTop - _self.reel_holder_info.symbol_height && _reelStop_px  < _currentMarginTop + _self.reel_holder_info.symbol_height) {
			_teaserNum = 3;
			Backbone.mediator.trigger( 'playSound' , _self.teaser[_teaserNum].sound );
			if(_self.active_reels.length <= 1) {
				if(_.has(_self.active_reels, _currentReelID)) {
					delete _self.active_reels[_currentReelID];
				}
				Backbone.mediator.trigger( 'stopSound' , _self.currentReelSound );
				_self.evaluateGameResult();
				return false;
			}
		} else {
			_teaserNum = ~~(Math.random()*3);
		}
		var _teaserSettings = _self.teaser[_teaserNum];
		$_reel.stop().animate({
				'margin-top': _reelStop_px
			}, _teaserSettings.speed, _teaserSettings.easing , function () {
				if(_.has(_self.active_reels, _currentReelID)) {
					delete _self.active_reels[_currentReelID];
				}
				if( _teaserNum !== 3 ) {
					Backbone.mediator.trigger( 'playSound' , _self.teaser[_teaserNum].sound );
				}
				if(jQuery.isEmptyObject(_self.active_reels)) {
					// the last active reel
					Backbone.mediator.trigger( 'stopSound' , _self.currentReelSound );
					_self.evaluateGameResult();
				}
			}
		);
	},
	/*
		This section has something to do with credits / money
	*/
	evaluateGameResult: function () {
		var $_reels = $('.reel');
		$_reels.stop();
		// reset current_totalPayout to 0
		this.current_totalPayout = 0
		// vars declaration
		var _totalPayout = 0;
		var _payout = 0;
		var _symbol_name = '';
		// vars for adding shiny to winning combinations
		var _stopNum_counter;
		var _totalStops;
		var _SVDM = this.symbol_vfx_display_matrix;
		// console.log(this.symbol_vfx_display_matrix);
		/*
		Scan for all the winning combinations from the current set of symbol combinations
		*/
		for(var _i = 0; _i < this.current_wins.length ; _i++ ) {
			_symbol_name = this.current_wins[_i].combination;
			if(_symbol_name === 'three_cherries' || _symbol_name === 'two_cherries') {
				_symbol_name = 'cherry';
			}
			_payout = this.current_wins[_i].payout;
			_totalPayout = _totalPayout + _payout;
		}
		//
		for(var _column = 0; _column < 3; _column++) { // Column
			// _column or _row ranges from 0 to 2
			_stopNum_counter = this.reel_info['reel-' + (_column + 1)].stopNum;
			_totalStops = this.reel_info['reel-' + (_column + 1)].totalStops
			for(var _row = 0; _row < 3; _row++) { // Row
				if(_SVDM[_row][_column].length > 0) {
					// add shiny if the symbol is one of winning combinations
					$('#reel-'+(_column + 1)+' div.symbol.stop_'+_stopNum_counter).addClass('shiny');
				}
				if(_stopNum_counter >= _totalStops - 1){
					_stopNum_counter = 0;
				} else {
					_stopNum_counter++;
				}
			}
		}

		// update winner segment display
		Gframe.memory.mov({
			id: 'winner_paid',
			value: _totalPayout,
		});
		this.current_totalPayout = _totalPayout;

		// This timer should not exist at this time, but just in case.
		Gframe.clock.removeTimer('creditSegmentAnimation_countDown');

		// payout
		if(_totalPayout > 0) {
			// add up the payout (internally for now)
			this.current_credits += _totalPayout;
			this.awardPlayer();
		} else {
			// no payout. return to normal without any handlings.
			Backbone.mediator.trigger( 'gameStartReady' , true);
		}
	},
	awardPlayer: function () {
		var _current_totalPayout = this.current_totalPayout;
		var _payoutSoundID = '';

		if(_current_totalPayout >= 500) {
			_payoutSoundID = 'handpay_bell';
		} else if(_current_totalPayout >= 50) {
			_payoutSoundID = 'payout_4';
		} else if(_current_totalPayout >= 10) {
			_payoutSoundID = 'payout_3';
		} else if(_current_totalPayout >= 3) {
			_payoutSoundID = 'payout_2';
		} else {
			_payoutSoundID = 'payout_1';
		}

		// play awards sound
		Backbone.mediator.trigger( 'playSound' , _payoutSoundID);


		if(_current_totalPayout >= 500) {
			// hand pay
			var _self = this;
			// set a delay timer for the handpay bell
			Gframe.clock.addTimer({
				'id': 'wait_for_handpayment_bell',
				'loop': 0,
				'frequency': 5625, // the handpay bell lasts for about 5625 milliseconds
				'setInterval': false, // use setTimeout mode
				timerFunction: function () {
					// forcing users to hear the bell sound
					Backbone.mediator.trigger( 'gameStartReady' , true);
					// now the big_payout BGM
					Backbone.mediator.trigger( 'playSound' , 'big_payout');
					// now begin the segment animation, counting up.
					_self.startSegmentCountAnimation();
					// start VFX
					Gframe.vfx.showVFX('coins_bigWin');
					// this timer is to be removed
					Gframe.clock.removeTimer('wait_for_handpayment_bell');
				}
			});
			Gframe.clock.startTimer('wait_for_handpayment_bell');
		} else {
			// regular payout
			// now begin the segment animation, counting up.
			// coin VFX only when the payout is more than 10.
			if(_current_totalPayout >= 10) {
				Gframe.vfx.showVFX('coins_smallWin');
			}
			Backbone.mediator.trigger( 'gameStartReady' , true);
			this.startSegmentCountAnimation();
		}
	},
	/*
		startSegmentCountAnimation()
		sets Timer for the payout segment counting routine
	*/
	startSegmentCountAnimation: function () {
		var _self = this;
		var _loop = 0;
		var _credits_being_countedup = Gframe.memory.get('credits').attributes.value;
		var _current_credits = this.current_credits;
		var _current_totalPayout = this.current_totalPayout;
		var _countup_amount = Math.ceil(Math.sqrt(_current_totalPayout / 50));
		// console.log(_countup_amount);
		Gframe.clock.addTimer({
			'id': 'creditSegmentAnimation',
			'loop': -1,
			'frequency': 50,
			'setInterval': true,
			timerFunction: function () {
				Gframe.memory.mov({
					id: 'credits',
					value: _credits_being_countedup,
				});
				// count up has ended
				if(_current_credits <= _credits_being_countedup) {
					_self.updateCreditSegment();
					// we do not know which one will be
					Backbone.mediator.trigger( 'stopSound' , 'big_payout');
					Backbone.mediator.trigger( 'stopSound' , 'payout_4');
					Backbone.mediator.trigger( 'stopSound' , 'payout_3');
					// remove any VFX
					Gframe.vfx.eraseVFX();
					// remove timer
					Gframe.clock.removeTimer('creditSegmentAnimation');
				} else {
					_credits_being_countedup += _countup_amount;
					if(_current_credits <= _credits_being_countedup) {
						_credits_being_countedup = _current_credits;
					}
				}
			}
		});
		Gframe.clock.startTimer('creditSegmentAnimation');
	},
	updateCreditSegment: function () {
		Gframe.memory.mov({
			id: 'credits',
			value: this.current_credits,
		});
	},
	/*
		credit deduction.
		return false if the credit is insufficient

		_bet_amoount ranges from 1 ~ 3
	*/
	decreaseCredits: function ( ) {
		var _self = this;
		var _bet_amount = this.current_bet_amount;
		var _credits_being_counteddown = Gframe.memory.get('credits').attributes.value;
		// if(this.current_credits > _bet_amoount )
		// deduct credits
		this.current_credits -= _bet_amount;
		// update segment
		Gframe.clock.addTimer({
			'id': 'creditSegmentAnimation_countDown',
			'loop': -1,
			'frequency': 50,
			'setInterval': true,
			timerFunction: function () {
				Gframe.memory.mov({
					id: 'credits',
					value: _credits_being_counteddown,
				});
				// count down has ended
				if(_self.current_credits >= _credits_being_counteddown) {
					_self.updateCreditSegment();
					// remove timer
					Gframe.clock.removeTimer('creditSegmentAnimation_countDown');
				} else {
					// keep the counting donw
					_credits_being_counteddown -= 1;
				}
			}
		});
		Gframe.clock.startTimer('creditSegmentAnimation_countDown');
		// play sound
		Backbone.mediator.trigger( 'playSound' , 'bet_' + _bet_amount );
		return true;
	},
	/*
		toggle play mode state
		true when the reels are spinning
	*/
	gameStartReady: function ( _state) {
		var $_spin_button = $('#spin_reels');
		var $_bet_buttons = $('.bet.button');
		if(_state === false) {
			this.inPlay = true;
			$_spin_button.removeClass('enabled').removeClass('blink');
			$_bet_buttons.removeClass('enabled');
			// keep winner_paid segment flashing while spinning the reels
			Gframe.segment.update_segment(
				'winner_paid',
				{
					'forceClock': true,
					'clockSettings': {
						'loop': -1,
						'frequency': 100,
						timerFunction: function () {
							Backbone.mediator.trigger( 'updateSegmentAnimation_winner_paid' , 'flash' );
						}
					}
				}
			);
			this.reelReady = 0;
		} else {
			this.inPlay = false;
			$_spin_button.addClass('enabled').addClass('blink');
			$_bet_buttons.addClass('enabled');
			// keep the winner_paid segment lit
			Gframe.segment.update_segment(
				'winner_paid',
				{
					'forceClock': false,
					'clockSettings': null
				}
			);
			Gframe.segment.activate_segment('winner_paid',true);
		}
	}
});

/*
	New instance for the Audio created in Gframe.js (as it will try to avoid loading when unnecessary
	new Gframe.backbone.views.audio;
